PEP: 0999
Title: Python minimization
Version: $Revision$
Last-Modified: $Date$
Author: 
Sponsor: 
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 15-Sep-2020


Abstract
========

This PEP aims to provide a way to minimize the footprint of Python on the hard drive for constrained environments like containers. Two of the possible solutions are provided for discussion.


Motivation
==========

The footprint of an installed Python tends to be quite large on most distributions.
This is not always desirable. In use cases such as containers, there are efforts to keep the disk size as minimal as possible. We would like to provide a standardized way to accomplish this minimization so that downstream distributors don't have to reinvent the wheel, rely on hacks and/or break users expectations.


Rationale
=========

The authors of this PEP have not settled on the specific mechanism for minimization yet. We would like to present two possible approaches for discussion.


Option 1: Shipping only ``.py`` files, and disabling creation of ``.pyc`` files
-------------------------------------------------------------------------------

A simple way of saving space is not shipping ``.pyc`` bytecode files, as they are not strictly necessary. Python programs will run fine from only ``.py`` source files. They will take a bit longer to start, but in our testing the slowdown is acceptable. For example, importing ``importlib.py`` takes on average 0.025s longer on our machines compared to the ``.pyc`` bytecode file.

The problem with this method is that when Python imports a ``.py`` source file without finding a corresponding and up to date ``.pyc`` bytecode file in ``__pycache__``, it will try to create it. This is undesirable for three reasons:

1. when Python is run by the user, they likely won't have permissions to create the file on the root filesystem, and an error message will be generated,
2. the disk footprint will start to grow, defeating the purpose of minimization, and
3. many Python distributors, e.g. Linux distros, have a way to track and verify installed files. Having files of unknown origin being generated in the background on the root filesystem is ill advised.

To remedy this, we propose that distributors place a marker file in each ``__pycache__`` directory that is to be write-protected. When Python loads a ``.py`` file, it would look for such marker file in the corresponding ``__pycache__`` directory and it would skip writing the ``.pyc`` file if marker is detected. The use of a file as a marker would make this easy to configure and verify this mechanism for distributors and users alike.


Option 2: Shipping the non-optimized ``.pyc`` files and compressed ``.py`` source files
---------------------------------------------------------------------------------------

While option 1 has its advantages, it suffers from needing a new kind of a marker and somewhat slower start times.

Option 2 involves downstream distributors shipping non-optimized ``.pyc`` bytecode files instead of ``.py`` source files. The non-optimized ``.pyc`` bytecode files would be placed in the same directory where the ``.py`` source files would have been (i.e. outside of ``__pycache__``). That is because files inside ``__pycache__`` are checked only if a corresponding ``.py`` file exists in the directory above.

To save space further, the *optimized* ``.pyc`` bytecode files (optimization levels 1 and 2) would not be shipped. This would, however, lead to situations where users running Python with optimizations (switches ``-O``, ``-OO``, envvar ``PYTHONOPTIMIZE``) would instead execute non-optimized versions of Python standard library modules. Authors of this PEP believe that this would not have an adverse impact. If desired, however, a mechanism could be devised which would skip the relevant bytecode parts on the fly when loading the non-optimized ``.pyc`` bytecode file when running in an optimized mode.

Shipping only ``.pyc`` bytecode files is achievable even now without any changes to Python. However, the authors believe that the solution, as is, would be problematic because Python tools generally assume and depend on the presence of the ``.py`` source files. One prominent example are Python tracebacks, which would no longer display line numbers and code snippets useful for debugging purposes.

To remedy this, we propose instituting a new optional ``__pysources__`` directory, which would hold Python ``.py`` source files in a compressed format. Python would primarily load the non-optimized ``.pyc`` files for execution, but where necessary, it could load the compressed source file as well, for example to display a traceback. Distributors wishing to use this mechanism would need to ship Python with the optional ``zlib`` module included.


Specification
=============

Size impact
-----------

To calculate the impact of these optimization efforts on size of the Python standard library we'll be using the `python3-libs`_ RPM package in Fedora. The Python standard library is vast and we believe it is not representative of what "batteries-included Python" means to users in modern constrained environments, such as containers. The `python3-libs`_ package in Fedora (and similarly in CentOS/RHEL), on the other hand, has already made a lot of choices on what should and should not be included in such an environment. On top of this, the `python3-libs` has already achieved a slightly smaller footprint by hardlinking ``.pyc`` bytecode files between optimization levels where they are identical.

`python3-libs`_ in Fedora contains the following optional components: TODO XXX

On the other hand, the following components are not included in `python3-libs`_ and are separated into different optional RPM packages: ``IDLE``, ``tkinter``, ``turtle``, ``turtledemo``, and ``test``. Also not included in `python3-libs`_ are the ``test`` subdirectories of the following components: ``ctypes``, ``distutils``, ``lib2to3``, ``sqlite3``, and ``unittest``.

Size is calculated using ``du -c $UNPACKED/usr/lib64/python3.9`` (converted to MiBs by dividing by 1024 and rounding to 2 decimal places) on x86_64, where ``$UNPACKED`` is the unpacked python3-libs RPM.


=======================================================================================  ==================================  =================  ===============
  Option                                                                                 Size of ``/usr/lib(64)/python3.9``  Difference in MiB  Difference in %
=======================================================================================  ==================================  =================  ===============
Status quo before change                                                                 31.76 MiB
Option 1: Shipping only ``.py`` files, and disabling creation of ``.pyc`` files          15.23 MiB                           -16.53 MiB         -52.05%
Option 2: Shipping the non-optimized ``.pyc`` files and compressed ``.py`` source files  17.18 MiB                           -14.58 MiB         -45.91%
=======================================================================================  ==================================  =================  ===============

TODO XXX Option 1 in Miro's FC is 14.72 MiB	but I have it as 15.23 - why? Older version of python3.9? Or maybe ``encoding/*.pycs`` and ``pydoc_data/topics.pyc`` ? I kept them.


Directory structure
-------------------

Option 1: Shipping only ``.py`` files, and disabling creation of ``.pyc`` files
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The marker file preventing ``.pyc`` bytecode files to be created could be put into the ``__pycache__``
directory as follows::

    project/
    ├── some_file.py
    └── __pycache__
        └── __dont_write_bytecode__

This tells the interpreter that, upon import, it should not create and write a
bytecompiled cache for later use in this ``__pycache__`` directory.

This file could be empty or contain any content. The interpreter would only check for its
presence, the contents would not be read.

Option 2: Shipping the non-optimized ``.pyc`` files and compressed ``.py`` source files
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The directory structure containing the non-optimized ``.pyc`` bytecache and the compressed sources could be as follows::

    project/
    ├── some_file.pyc
    └── __pysources__
        └── some_file.zpy

Since the ``project`` directory would not contain any ``.py`` source files, a ``__pycache__`` directory would not be present.

Python would first load the non-optimized ``.pyc`` bytecode file for execution, and if it needed access to the sources, it would unpack and load the compressed sources as well from the corresponding file in ``__pysources__``.


Backwards Compatibility
=======================

This pep has no implications on backwards compatibility.


How to Teach This
=================

The targeted group of users for this PEP are downstream Python distributors, such as Linux distributions, which are presumed to be aware of new PEPs and related discussions.


Reference Implementation
========================

`Option 1: Shipping only .py files, and disabling creation of .pyc files`_

`Option 2: Shipping the non-optimized .pyc files and compressed .py source files`_


Rejected Ideas
==============

Fedora is already shipping Python with a slightly smaller footprint. The Python standard library contains a lot of modules where the ``.pyc`` bytecode files are identical between optimization levels. For example some non-optimized ``.pyc`` files are identical to ``.pyc`` files of optimization level 1 (and sometimes level 2 as well). Due to this, Fedora has been able to reduce the disk footprint by hardlinking these files in cases where they are identical. However, the disk size saved was relatively minor, at 4.0 MiB or 10.7 % of Fedora's ``python3-libs`` RPM package.

To minimize the footprint further, a range of ideas was considered, see `Python minimization in Fedora`_. These ideas have been then discussed on this `Fedora devel mailing list thread`_.


Open Issues
===========

The exact method to accomplish the minimization has not yet been settled on. We propose two base methods that we feel represent the best ways forward. Whether one of those, a combination of those, or perhaps a yet different solution is chosen remains an open issue.


References
==========

.. _`Python minimization in Fedora`:
   https://github.com/hroncok/python-minimization/blob/master/document.md
.. _`Fedora devel mailing list thread`:
   https://lists.fedoraproject.org/archives/list/devel@lists.fedoraproject.org/thread/LACP3PFQPUO6BQQLYYJDFF4CR3DHWRSQ/

.. _`Option 1: Shipping only .py files, and disabling creation of .pyc files`:
   https://github.com/encukou/cpython/tree/minimization-marker
.. _`Option 2: Shipping the non-optimized .pyc files and compressed .py source files`:
   https://github.com/encukou/cpython/tree/minimization-src-from-pyc

.. _`python3-libs`:
   https://src.fedoraproject.org/rpms/python3.9

Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.



..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:

